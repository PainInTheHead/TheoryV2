# JS Basic Cheat Sheet

## Типы данных
- number → `42`, `NaN`, `Infinity`
- string → `"hi"`, `'hi'`, \`hi\`
- boolean → `true`, `false`
- null → отсутствие значения
- undefined → не задано
- symbol → уникальный идентификатор
- bigint → `123n`
- object → `{}`, `[]`, `function`

```js
typeof null // "object" (особенность JS)
typeof []   // "object"
Array.isArray([]) // true

//Преобразования типов

String(123)   // "123"
Number("42")  // 42
Boolean(0)    // false
+"5"          // 5
!!"hi"        // true

//typeof vs instanceof

typeof []          // "object"
[] instanceof Array // true
```
Оператор instanceof позволяет проверить, принадлежит ли объект указанному классу, с учётом наследования.

## Преобразования типов

```js
String(123)   // "123"
Number("42")  // 42
Boolean(0)    // false
+"5"          // 5
!!"hi"        // true
```

## Операторы    

### Операторы присваиваивания

#### Базовые

- = простое присваивание
- +=, -=, *=, /=, %=, **=

```js
let x = 5
x += 2  // 7
x **= 2 // 49
```

#### Побитовые присваивания

- &=, |=, ^=
- <<=, >>=, >>>=

```js
let y = 5
y &= 3   // 1
y <<= 1  // 2
```

#### Логические присваивания (ES2021+)

- &&= → присвоение, если слева truthy
- ||= → присвоение, если слева falsy
- ??= → присвоение, если слева null или undefined

```js
let a = 0
a ||= 10   // 10 (0 falsy)

let b = 5
b &&= 20   // 20 (5 truthy)

let c = null
c ??= 30   // 30 (c был null)
```

### Арифметические

-	+сложение
-	-вычитание
-	*умножение
-	/ деление
-	% остаток от деления
-	** возведение в степень
-	+x унарный плюс (приводит к числу)
-	-x унарный минус

```js
5 % 2    // 1
2 ** 3   // 8
+"5"     // 5
```

### Сравнения

-	== равно (с приведением типов)
-	!= не равно (с приведением типов)
-	=== строго равно
-	!== строго не равно
-	'>' больше
-	< меньше
-	'>=' больше или равно
-	<= меньше или равно

```js
2 == "2"   // true
2 === "2"  // false
```

### Логические

-	&& логическое И
-	|| логическое ИЛИ
-	! логическое НЕ
-	?? nullish coalescing (только null и undefined)
-	?. optional chaining

```js
0 || "hi"     // "hi"
null ?? "def" // "def"
obj?.prop     // undefined если obj = null
```

### typeof / instanceof / delete / in

-	typeof x → возвращает строку с типом
-	x instanceof Constructor → проверка по прототипу
-	prop in obj → проверка наличия свойства
-	delete obj.prop → удаление свойства

```js
typeof []         // "object"
[] instanceof Array // true
"length" in []    // true
```


### Побитовые

-	& AND
-	| OR
-	^ XOR
-	~ NOT
-	<< сдвиг влево
-	'>>' сдвиг вправо (с сохранением знака)
-	'>>>' сдвиг вправо (без знака)

```js
5 & 1   // 1
5 | 1   // 5
5 ^ 1   // 4
~5      // -6
5 << 1  // 10
5 >> 1  // 2
```

## 2. Переменные и область видимости

### var vs let vs const — кратко

1) var
- Функционально- (function) или глобально-область (если объявлено вне функции).
- Можно переобъявлять в одной области (var x; var x; — OK).
- Имеет hoisting: declaration поднимается, инициализируется как undefined.
- Игнорирует блочные {} границы (если блок внутри функции — всё равно function-scoped).
- Не использовать в новом коде — источник багов.
  
2) let
   
- Блочная область видимости (block-scoped).
- Нельзя переобъявлять в той же области (SyntaxError).
- Поддерживает hoisting без инициализации → TDZ (ReferenceError при доступе до объявления).
- Можно переназначать (reassign).

3) const

- Блочная область видимости.
- Обязателен инициализатор при объявлении (const x = ...).
- Нельзя переназначать саму привязку (binding) — const защищает ссылку.
- Содержимое объекта/массива можно изменять (мутабельность объекта не запрещена).
- Также затронут TDZ.

### Примеры и объяснения (важно для собеса)

```js
// var hoisting
console.log(a); // undefined
var a = 1;

// let/const + TDZ
console.log(b); // ReferenceError: Cannot access 'b' before initialization
let b = 2;

// const без инициализации
const c; // SyntaxError: Missing initializer in const declaration

// redeclare
var x = 1;
var x = 2; // OK

let y = 1;
let y = 2; // SyntaxError

// reassignment
let m = 1;
m = 3; // OK

const n = 1;
n = 2; // TypeError
```

### Hoisting — что конкретно происходит

1) Declaration (объявление) у var, let, const и функций появляется в начале области видимости.
2) Инициализация:
- var — инициализируется как undefined при подъёме → безопасно читать (получишь undefined).
- let/const — не инициализированы до исполнения строки объявления → TDZ.
- Function declaration ( function f(){} ) — поднимается полностью (можно вызывать до объявления).
- Function expression через var — переменная поднимается как undefined, а присвоение функции останется на месте → вызов до присвоения → TypeError.
  
  Примеры:

```js
  // function declaration
foo(); // "hi"
function foo() { console.log("hi"); }

// function expression
bar(); // TypeError: bar is not a function
var bar = function() { console.log("hey"); }
```

### TDZ (Temporal Dead Zone)

- Это период между входом в область видимости и фактическим выполнением объявления let/const.
- Любая попытка прочитать/использовать идентификатор в TDZ ведёт к ReferenceError.
- typeof тоже бросит ReferenceError для переменных в TDZ (в отличие от полностью несуществующих идентификаторов).

```js
console.log(typeof notDeclared); // "undefined" — переменная вообще не объявлена

console.log(typeof inTDZ); // ReferenceError (если позднее: let inTDZ = 1;)
let inTDZ = 1;
```

### Области видимости: global, function, block

1) Global (глобальная)

- В браузере: глобальный объект — window (но: в ES-модулях и в Node поведение другое).
- var вне функции (в старых не-модульных скриптах) станет свойством window. let/const — нет.
- Универсальный способ: globalThis — кросс-платформенный глобальный объект.

```js
// в обычном <script> (не-module)
var g = 1;
let l = 2;
console.log(window.g); // 1
console.log(window.l); // undefined
```

2) Function scope

var привязан к функции: если объявлен внутри функции — доступен во всей функции, даже до блоков.

```js
function f() {
  if (true) {
    var v = 1;
    let w = 2;
  }
  console.log(v); // 1
  console.log(w); // ReferenceError
}
```

3) Block scope

let/const видимы только внутри ближайших {}. Рекомендуется использовать блоки локальности для уменьшения побочных эффектов.

### Классический баг: var в циклах + замыкания

```js
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 0); // три раза 3 — потому что i одна общая переменная
}

for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 0); // 0,1,2 — отдельная привязка i для каждой итерации
}
```

### const с объектами/массивами

- const arr = [] — нельзя переназначить arr = ..., но можно arr.push(...).
- const obj = {} — можно менять свойства obj.x = 1.

```js
const o = { a: 1 };
o.a = 2; // OK
o = {};  // TypeError
```

### Модульный контекст (ES Modules) — важный нюанс

- В ES modules (`<script type="module">` или `import`/`export`) всё на верхнем уровне — модульная видимость, а не глобальная.  
- В модулях объявления var/let/const не добавляют свойства в window.
- Для кросс-платформенного обращения к глобальному объекту используйте globalThis.

### Практические рекомендации / лучшие практики (для собеса и реального кода)

- По умолчанию const — для всех переменных, которые не предполагается переназначать.
- Для изменяемых — let.
- Не использовать var в новом коде (в редких legacy-случаях можно применить).
- Избегать глобальных переменных; предпочесть модули или IIFE/локальные области.
- Не объявлять функции внутри блоков в кросс-браузерном коде (может быть двусмысленно).
- Для циклов/таймаутов/замыканий — использовать let чтобы не ловить типичные баги.
- Помните про TDZ — не пытайтесь заранее использовать переменные до объявления.

### Частые вопросы на собеседовании (короткие ответы)

- В чём разница между var и let?

var — function-scoped, допускает redeclare, hoisted → undefined. let — block-scoped, нельзя redeclare, TDZ до объявления.
- Что делает const?

Запрет на переназначение привязки; значение привязки (если объект) остаётся мутабельным.
- Что такое hoisting?

Подъём деклараций (объявлений) в начало области видимости. Инициализация зависит от типа (var = undefined, let/const — нет).
- Что такое TDZ?

Временная зона, когда переменная существует лексически, но не инициализирована — доступ вызывает ReferenceError.
- Почему typeof на несуществующую переменную возвращает undefined, а на let в TDZ бросает ошибку?

typeof безопасен для полностью отсутствующих идентификаторов, но для существующих, но неинициализированных (TDZ) — доступ запрещён.

## 3. Функции

### Function Declaration vs Function Expression vs Arrow Function

#### Function Declaration
- Объявление функции через `function name() {}`.
- Hoisting: функция полностью поднимается → можно вызвать до объявления.
- Имеет собственный `this` (динамический, зависит от вызова).
- Может быть использована как конструктор (`new`).

```js
foo(); // "hi"
function foo() { console.log("hi"); }

// Можно использовать как конструктор
function Person(name) { this.name = name; }
const p = new Person("Alex"); // { name: "Alex" }
```


---

## 🧩 3 Function Declaration vs Function Expression vs Arrow Function

### 1. Function Declaration
```js
function greet(name) {
  return `Hello, ${name}!`;
}
```
- **Hoisting**: Поднимается целиком (можно вызвать до объявления).
- **Имя**: Обязательно имеет имя.
- **`this`**: Зависит от контекста вызова (обычный `this`).

> 💡 Подводный камень:  
> Если объявить функцию внутри блока (`if`, `for`), в строгом режиме она будет доступна только внутри этого блока (в ES6+), но в старых движках — ведёт себя по-разному.

---

### 2. Function Expression
```js
const greet = function(name) {
  return `Hello, ${name}!`;
};
```
- **Hoisting**: Только переменная поднимается (`undefined` до инициализации).
- **Анонимность**: Может быть анонимной, но лучше именовать для дебага:
  ```js
  const greet = function greetNamed(name) { ... }
  ```
- **`this`**: Как и в declaration — зависит от контекста вызова.

> 💡 Нюанс:  
> Именованная функция внутри expression доступна только внутри себя (для рекурсии, например), но не снаружи:
> ```js
> const f = function rec(n) {
>   if (n <= 1) return 1;
>   return n * rec(n - 1); // rec доступна здесь
> };
> rec(5); // ReferenceError: rec is not defined
> ```

---

### 3. Arrow Function
```js
const greet = (name) => `Hello, ${name}!`;
```
- **Hoisting**: Не поднимается (как `const`/`let`).
- **`this`**: **Лексический `this`** — берётся из окружающей области видимости. **Не имеет своего `this`**.
- **Не имеет**: `arguments`, `super`, `new.target`.
- **Не может быть конструктором** (`new greet()` → ошибка).

> 💥 Подводные камни:
> - ❌ `this` не привязывается к объекту, даже если функция — метод объекта:
>   ```js
>   const obj = {
>     name: 'Alice',
>     greet: () => console.log(this.name) // undefined (this → window/global)
>   };
>   ```
> - ❌ Не работает `bind`, `call`, `apply` для изменения `this` (игнорируются):
>   ```js
>   const f = () => console.log(this);
>   f.call({x: 1}); // this не изменится!
>   ```

> ✅ Когда использовать:  
> - Колбэки, где нужен внешний `this` (например, в React-хуках, обработчиках событий).
> - Короткие функции, map/filter/reduce.

---

## ⚙️ Параметры по умолчанию и Rest-параметры

### Параметры по умолчанию
```js
function greet(name = 'Anonymous', age = 18) {
  return `${name}, ${age}`;
}
```
- Вычисляются **в момент вызова**, а не объявления.
- Можно использовать выражения и даже вызовы других функций:
  ```js
  function f(a = getDefault()) { ... }
  ```
- **TDZ (Temporal Dead Zone)**: если параметр по умолчанию ссылается на другой параметр, который ещё не инициализирован — будет ошибка:
  ```js
  function f(a = b, b = 1) { } // ReferenceError: Cannot access 'b' before initialization
  ```

> 💡 Нюанс:  
> Параметры по умолчанию создают **новую область видимости**:
> ```js
> let x = 1;
> function f(a = x) {
>   let x = 2; // ← это x не влияет на a, т.к. a инициализируется в "параметрической" области
>   console.log(a); // 1
> }
> ```

---

### Rest-параметры (`...args`)
```js
function sum(...numbers) {
  return numbers.reduce((a, b) => a + b, 0);
}
```
- Всегда **массив**.
- Должен быть **последним** параметром.
- Не путать с `arguments` (rest — настоящий массив, `arguments` — array-like).

> 💥 Подводный камень:  
> `arguments` **не обновляется** при изменении rest-параметров (и наоборот):
> ```js
> function f(...args) {
>   args[0] = 999;
>   console.log(arguments[0]); // не изменится (если не strict mode — зависит от движка)
> }
> ```

> ✅ Используй rest вместо `arguments` — он чище, современнее и типизируется лучше.

---

## 🔐 Замыкания (Closures)

**Замыкание** — это функция, которая запоминает («замыкает») переменные из внешней области видимости, даже после того, как эта область завершила выполнение.

```js
function outer() {
  let counter = 0;
  return function inner() {
    counter++;
    return counter;
  };
}

const inc = outer();
console.log(inc()); // 1
console.log(inc()); // 2 ← counter сохранён!
```

> 💡 Что замыкает:  
> Не значение, а **ссылку на переменную**. Это важно при использовании в циклах:
> ```js
> for (var i = 0; i < 3; i++) {
>   setTimeout(() => console.log(i), 0); // выведет 3, 3, 3
> }
> ```
> Решение: `let` (блочная область) или IIFE:
> ```js
> for (let i = 0; i < 3; i++) { ... } // 0, 1, 2
> ```

> 💥 Подводные камни:
> - Утечки памяти: если замыкание ссылается на большой объект и "висит" — GC не сможет его собрать.
> - В циклах с `var` — все функции ссылаются на одну и ту же переменную.

> ✅ Применение:  
> - Модули, приватные переменные.
> - Фабрики функций.
> - Каррирование, мемоизация.

---

## 🎯 Контекст `this`

`this` — это **контекст вызова функции**, определяется **не где она объявлена, а как вызвана**.

### 1. Global Context
```js
console.log(this); // window (браузер) / global (Node.js)
function f() { return this; } // в нестрогом режиме → window/global
```
> ❗ В strict mode: `this` внутри функции → `undefined`.

---

### 2. Object Method
```js
const obj = {
  name: 'Alice',
  greet() {
    return this.name;
  }
};
obj.greet(); // 'Alice' ← this = obj
```
> 💡 Но если "оторвать" метод:
> ```js
> const g = obj.greet;
> g(); // undefined (this → global/undefined в strict)
> ```

---

### 3. Class
```js
class Person {
  constructor(name) {
    this.name = name;
  }
  greet() {
    return this.name;
  }
}
```
- В методах класса `this` — экземпляр класса.
- **Arrow functions в классе** — привязывают `this` к экземпляру (часто используются для обработчиков):
  ```js
  class Component {
    handleClick = () => {
      console.log(this); // всегда экземпляр Component
    }
  }
  ```

---

### 4. call / apply / bind

- **`call(context, arg1, arg2, ...)`** — вызывает функцию с указанным `this` и аргументами по одному.
- **`apply(context, [args])`** — то же, но аргументы — массивом.
- **`bind(context, arg1, ...)`** — возвращает новую функцию с привязанным `this` и частичными аргументами.

> 💥 Подводный камень:
> - `bind` возвращает **новую функцию**, не вызывает сразу.
> - `bind` можно использовать для каррирования:
>   ```js
>   function f(a, b) { return a + b; }
>   const f1 = f.bind(null, 1);
>   f1(2); // 3
>   ```

> ❗ `bind(null)` в нестрогом режиме → `this = window/global`, в строгом — `null`.

> ✅ Используй `bind` для привязки контекста в обработчиках событий, колбэках.

---

### Особенности `this` в стрелочных функциях
```js
const obj = {
  name: 'Alice',
  greet: () => this.name // this → не obj, а внешний scope (например, window)
};
```
> 🚫 Стрелочные функции **игнорируют** `call/apply/bind` для `this`.

---

## 🔄 IIFE — Immediately Invoked Function Expression

Функция, которая вызывается сразу после объявления.

```js
(function() {
  var privateVar = 'secret';
  console.log(privateVar);
})();
```
или
```js
(() => {
  const privateVar = 'secret';
  console.log(privateVar);
})();
```

### Зачем?
- Изоляция области видимости (до появления модулей и блочной области `let/const`).
- Создание замыканий с фиксированным состоянием.
- Инициализация модулей.

> 💡 Современная альтернатива — блоки + `let/const` или ES-модули.

> 💥 Подводный камень:
> Без скобок вокруг function expression — синтаксическая ошибка:
> ```js
> function() { ... }(); // SyntaxError
> (function() { ... })(); // OK
> ```

> ✅ Можно передавать параметры:
> ```js
> (function(global) {
>   global.myLib = {};
> })(window);
> ```

Конечно! Ниже — **чёткий, без воды, но полный** блок по **лексическому окружению (Lexical Environment)** — именно то, что нужно для собеседования на мидла. Это фундамент замыканий, контекста и области видимости.

---

## 🌐 Лексическое окружение (Lexical Environment)

### Что это?
**Лексическое окружение** — это спецификационная структура (не доступна напрямую в коде), которая хранит:
- **Environment Record** — записи всех переменных и функций в текущей области видимости.
- **Ссылку на внешнее лексическое окружение** (outer lexical environment).

> 💡 Каждый вызов функции создаёт **новое лексическое окружение**.

---

### Как работает?

```js
let a = 1;

function f() {
  let b = 2;
  function g() {
    let c = 3;
    console.log(a, b, c); // 1, 2, 3
  }
  return g;
}

const inner = f();
inner(); // всё ещё видит a и b — потому что g замкнула свои внешние окружения!
```

- При вызове `f()` → создаётся LE (лексическое окружение) для `f`, где есть `b` и ссылка на глобальное LE (где `a`).
- При создании `g` внутри `f` → `g` сохраняет ссылку на LE `f` (не на момент вызова, а на момент **создания**!).
- Когда `g` вызывается позже → она идёт по цепочке: `g.LE → f.LE → global.LE`.

> ✅ Это и есть **замыкание** — функция + её лексическое окружение на момент создания.

---

### Важные нюансы (для собеседования)

#### 1. **Создаётся при объявлении функции, а не при вызове**
```js
function makeCounter() {
  let count = 0;
  return function() {
    return ++count;
  };
}

const counter1 = makeCounter();
const counter2 = makeCounter();

console.log(counter1()); // 1
console.log(counter1()); // 2
console.log(counter2()); // 1 ← свой отдельный LE!
```
→ Каждый вызов `makeCounter()` создаёт **новое** лексическое окружение → каждая вложенная функция замыкает своё.

---

#### 2. **Не копирует значения — хранит ссылки**
```js
function f() {
  let x = 1;
  return {
    getX: () => x,
    setX: (val) => x = val
  };
}

const obj = f();
console.log(obj.getX()); // 1
obj.setX(5);
console.log(obj.getX()); // 5 ← одна и та же переменная!
```

---

#### 3. **Циклы + var = беда (из-за одного LE)**
```js
var arr = [];
for (var i = 0; i < 3; i++) {
  arr[i] = function() { return i; };
}
console.log(arr[0]()); // 3 ← все функции ссылаются на один i из одного LE!
```
→ Решение: `let` (создаёт новое LE на каждой итерации) или IIFE.

---

#### 4. **Стрелочные функции тоже создают LE, но без своего `this` и `arguments`**
```js
function outer() {
  let x = 10;
  return () => x; // стрелка замыкает x из outer — LE работает так же!
}
```

---

#### 5. **Блоки тоже создают LE (если есть let/const/class)**
```js
{
  let blockVar = 'secret';
  function f() { return blockVar; } // замыкает blockVar
}
// blockVar недоступна здесь, но если f "вышла" наружу — она всё ещё имеет доступ!
```

> 💡 В ES6+ блоки с `let/const` создают **блочное лексическое окружение**.

---

## 🧠 Что спрашивают на собеседовании (Mid-level)

### ❓ Что такое лексическое окружение?
→ Структура, хранящая переменные текущей области + ссылку на внешнюю область. Создаётся при входе в блок/функцию.

### ❓ Чем отличается от scope?
→ Scope — это более общее понятие («где переменная доступна»), LE — это **механизм реализации scope** в спецификации JS.

### ❓ Почему замыкание «помнит» переменные?
→ Потому что функция хранит скрытую ссылку на LE, в котором была создана. Даже если внешняя функция завершилась — её LE остаётся в памяти, пока есть ссылки (через замыкания).

### ❓ Может ли замыкание изменить внешнюю переменную?
→ Да, потому что оно хранит **ссылку**, а не копию значения.

### ❓ Почему в цикле с `var` все функции возвращают одно значение?
→ Потому что `var` не создаёт новое LE на каждой итерации — все функции ссылаются на одну переменную из одного LE.

### ❓ Удаляется ли LE, когда функция завершается?
→ Да, **если нет замыканий**. Если есть — LE остаётся в памяти, пока живы замыкающие функции → возможны утечки.

---

## 🎯 Вывод для мидла

- **LE — это механизм, на котором держатся scope, замыкания, подъём (hoisting), this (частично)**.
- **Функция всегда запоминает LE, в котором была создана** — это основа замыканий.
- **LE создаётся на этапе выполнения**, а не парсинга (но структура определяется лексически — отсюда название).
- **Понимание LE = понимание 80% вопросов по области видимости и замыканиям**.

---

## 🧠 Бонус: Частые вопросы на собеседованиях (Mid-level)

1. **Чем отличается `function declaration` от `function expression`?**  
   → Hoisting, именование, область видимости.

2. **Почему стрелочная функция не подходит как метод объекта?**  
   → Потому что `this` лексический, не привязывается к объекту.

3. **Как исправить проблему с `i` в цикле и `setTimeout`?**  
   → `let`, IIFE, `bind`, или передача параметра в стрелочную функцию.

4. **Что такое замыкание и где оно используется?**  
   → Приватные переменные, модули, фабрики, мемоизация.

5. **Как работает `bind`? Можно ли его переопределить?**  
   → Создаёт новую функцию с фиксированным `this`. Повторный `bind` игнорируется.

6. **В чём разница между `call` и `apply`?**  
   → Способ передачи аргументов: по одному vs массивом.

7. **Что выведет `console.log(this)` в стрелочной функции в глобальной области?**  
   → Зависит от окружения: в браузере — `window`, в модуле — `undefined`.

8. **Можно ли использовать `new` со стрелочной функцией?**  
   → ❌ Нет, ошибка.

9. **Как передать контекст в `setTimeout`?**  
   → `setTimeout(func.bind(context), delay)` или стрелочная функция.

10. **Что делает IIFE и зачем он нужен сегодня?**  
    → Изолирует scope. Сегодня чаще используются модули и блоки.

---